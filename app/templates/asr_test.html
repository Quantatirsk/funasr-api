<!DOCTYPE html>
<html>
<head>
    <title>ASRå®æ—¶è¯­éŸ³è¯†åˆ«æµ‹è¯•</title>
    <meta charset="utf-8">
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .header { text-align: center; margin-bottom: 30px; }
        .form-row { display: flex; gap: 20px; margin-bottom: 15px; align-items: end; }
        .form-group { flex: 1; }
        .form-group.small { flex: 0 0 150px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; color: #333; }
        input, select { width: 100%; padding: 8px; box-sizing: border-box; border: 1px solid #ddd; border-radius: 4px; }
        button { background: #007bff; color: white; padding: 10px 20px; border: none; cursor: pointer; border-radius: 4px; font-size: 14px; margin: 5px; }
        button:hover { background: #0056b3; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        button.success { background: #28a745; }
        button.danger { background: #dc3545; }
        .controls { text-align: center; margin: 20px 0; }
        .status { padding: 10px; margin: 10px 0; border-radius: 4px; }
        .status.info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        .status.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status.error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .status.warning { background: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
        .log { background: #f8f9fa; border: 1px solid #ddd; padding: 15px; height: 400px; overflow-y: auto; font-family: 'Courier New', monospace; font-size: 12px; border-radius: 4px; }
        .log-entry { margin: 2px 0; padding: 2px 5px; border-radius: 3px; }
        .log-entry.info { color: #0c5460; }
        .log-entry.success { color: #155724; }
        .log-entry.error { color: #721c24; background: rgba(248, 215, 218, 0.3); }
        .log-entry.warning { color: #856404; background: rgba(255, 243, 205, 0.3); }
        .result-container { margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 4px; }
        .result-text { font-size: 16px; line-height: 1.8; padding: 15px; background: white; border: 1px solid #ddd; border-radius: 4px; min-height: 150px; max-height: 300px; overflow-y: auto; white-space: pre-wrap; word-wrap: break-word; }
        .stats { display: flex; gap: 20px; margin: 15px 0; }
        .stat { background: #e9ecef; padding: 10px; border-radius: 4px; text-align: center; flex: 1; }
        .stat-value { font-size: 18px; font-weight: bold; color: #007bff; }
        .stat-label { font-size: 12px; color: #666; }
        .protocol-info { background: #e7f3ff; padding: 15px; margin: 15px 0; border-radius: 4px; border-left: 4px solid #007bff; }

        /* åè®®åˆ‡æ¢æ ‡ç­¾æ ·å¼ */
        .protocol-tabs {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e9ecef;
        }
        .tab-btn {
            padding: 12px 30px;
            font-size: 16px;
            border-radius: 25px;
            background: #f8f9fa;
            color: #666;
            border: 2px solid #dee2e6;
            transition: all 0.3s ease;
        }
        .tab-btn:hover {
            background: #e9ecef;
            transform: translateY(-2px);
        }
        .tab-btn.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
            box-shadow: 0 4px 12px rgba(0,123,255,0.3);
        }

        /* åŠ¨æ€é…ç½®åŒº */
        .config-section {
            display: none;
        }
        .config-section.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- åè®®åˆ‡æ¢æ ‡ç­¾ -->
        <div class="protocol-tabs">
            <button onclick="switchProtocol('aliyun')" class="tab-btn active" id="tab-aliyun">é˜¿é‡Œäº‘</button>
            <button onclick="switchProtocol('qwen3')" class="tab-btn" id="tab-qwen3">Qwen3-ASR</button>
        </div>

        <!-- åŠ¨æ€æ ‡é¢˜ -->
        <div class="header">
            <h1 id="pageTitle">ğŸ¤ é˜¿é‡Œäº‘å®æ—¶è¯­éŸ³è¯†åˆ«æµ‹è¯•</h1>
            <p id="pageDesc">WebSocketæµå¼è¯­éŸ³è¯†åˆ«åè®® - StartTranscription â†’ å‘é€éŸ³é¢‘æµ â†’ StopTranscription</p>
        </div>

        <!-- åè®®è¯´æ˜ -->
        <div class="protocol-info" id="protocolInfo">
            <strong>åè®®è¯´æ˜ï¼š</strong>æœ¬é¡µé¢æ”¯æŒé€šè¿‡éº¦å…‹é£å®æ—¶å½•éŸ³å¹¶è¿›è¡Œè¯­éŸ³è¯†åˆ«ã€‚ç‚¹å‡»"å¼€å§‹è¯†åˆ«"åï¼Œè¯´è¯å†…å®¹å°†å®æ—¶è½¬æ¢ä¸ºæ–‡å­—ã€‚
        </div>

        <!-- å…¬å…±é…ç½®ï¼šWebSocketåœ°å€ -->
        <div class="form-row">
            <div class="form-group">
                <label>WebSocketæœåŠ¡åœ°å€:</label>
                <input type="text" id="wsUrl" value="ws://localhost:8000/ws/v1/asr/funasr" />
            </div>
            <div class="form-group small" id="tokenGroup">
                <label>Token (å¯é€‰):</label>
                <input type="password" id="token" placeholder="è®¿é—®ä»¤ç‰Œ" />
            </div>
        </div>

        <!-- é˜¿é‡Œäº‘é…ç½®åŒº -->
        <div id="aliyun-config" class="config-section active">
            <div class="form-row">
                <div class="form-group">
                    <label>éŸ³é¢‘æ ¼å¼:</label>
                    <select id="aliyun-format">
                        <option value="pcm" selected>PCM (16ä½)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>é‡‡æ ·ç‡:</label>
                    <select id="aliyun-sampleRate">
                        <option value="8000">8000</option>
                        <option value="16000" selected>16000</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>ä¸­é—´ç»“æœ:</label>
                    <select id="aliyun-enableIntermediate">
                        <option value="true" selected>å¼€å¯</option>
                        <option value="false">å…³é—­</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>æ ‡ç‚¹é¢„æµ‹:</label>
                    <select id="aliyun-enablePunctuation">
                        <option value="true" selected>å¼€å¯</option>
                        <option value="false">å…³é—­</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Qwen3é…ç½®åŒº -->
        <div id="qwen3-config" class="config-section">
            <div class="form-row">
                <div class="form-group">
                    <label>éŸ³é¢‘æ ¼å¼:</label>
                    <select id="qwen3-format">
                        <option value="pcm" selected>PCM (16ä½)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>é‡‡æ ·ç‡:</label>
                    <select id="qwen3-sampleRate">
                        <option value="16000" selected>16000</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Chunkå¤§å°(ç§’):</label>
                    <select id="qwen3-chunkSizeSec">
                        <option value="0.5">0.5</option>
                        <option value="1.0">1.0</option>
                        <option value="2.0" selected>2.0</option>
                        <option value="4.0">4.0</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>å¼ºåˆ¶è¯­è¨€:</label>
                    <select id="qwen3-language">
                        <option value="" selected>è‡ªåŠ¨æ£€æµ‹</option>
                        <option value="Chinese">Chinese</option>
                        <option value="English">English</option>
                        <option value="Japanese">Japanese</option>
                        <option value="Korean">Korean</option>
                        <option value="French">French</option>
                        <option value="German">German</option>
                        <option value="Spanish">Spanish</option>
                    </select>
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>çƒ­è¯/ä¸Šä¸‹æ–‡:</label>
                    <input type="text" id="qwen3-context" placeholder="å¯é€‰: è¾“å…¥çƒ­è¯æˆ–ä¸Šä¸‹æ–‡æç¤º" />
                </div>
            </div>
        </div>

        <!-- å…¬å…±æ§åˆ¶æŒ‰é’® -->
        <div class="controls">
            <button id="startBtn" onclick="startRecognition()" class="success">ğŸ™ï¸ å¼€å§‹è¯†åˆ«</button>
            <button id="stopBtn" onclick="stopRecognition()" disabled class="danger">ğŸ›‘ åœæ­¢è¯†åˆ«</button>
            <button onclick="clearLog()">ğŸ—‘ï¸ æ¸…ç©ºæ—¥å¿—</button>
            <button onclick="clearResult()">ğŸ—‘ï¸ æ¸…ç©ºç»“æœ</button>
        </div>

        <div id="status" class="status info">å‡†å¤‡å°±ç»ªï¼Œç‚¹å‡»"å¼€å§‹è¯†åˆ«"æŒ‰é’®å¼€å§‹</div>

        <!-- éŸ³é¢‘å›æ”¾åŒºï¼ˆé˜¿é‡Œäº‘ç‰¹æœ‰ï¼‰ -->
        <div id="audioPlaybackContainer" class="result-container" style="display: none;">
            <h3>ğŸ”Š å½•éŸ³å›æ”¾:</h3>
            <audio id="audioPlayback" controls style="width: 100%; margin: 10px 0;"></audio>
            <button onclick="downloadAudio()" style="margin: 5px;">ğŸ’¾ ä¸‹è½½å½•éŸ³</button>
            <p style="font-size: 12px; color: #666;">æç¤º: å¯ä»¥æ’­æ”¾åˆšåˆšå½•åˆ¶çš„éŸ³é¢‘,æ£€æŸ¥å½•éŸ³è®¾å¤‡æ˜¯å¦æ­£å¸¸å·¥ä½œ</p>
        </div>

        <!-- å…¬å…±ç»Ÿè®¡åŒº -->
        <div class="stats">
            <div class="stat">
                <div class="stat-value" id="audioChunks">0</div>
                <div class="stat-label">éŸ³é¢‘å—æ•°</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="audioSize">0 KB</div>
                <div class="stat-label">éŸ³é¢‘å¤§å°</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="duration">0.0s</div>
                <div class="stat-label">è¯†åˆ«æ—¶é•¿</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="connectionState">æœªè¿æ¥</div>
                <div class="stat-label">è¿æ¥çŠ¶æ€</div>
            </div>
            <div class="stat" id="sentenceCountStat">
                <div class="stat-value" id="sentenceCount">0</div>
                <div class="stat-label">å¥å­æ•°</div>
            </div>
            <div class="stat" id="detectedLanguageStat" style="display: none;">
                <div class="stat-value" id="detectedLanguage">-</div>
                <div class="stat-label">æ£€æµ‹è¯­è¨€</div>
            </div>
        </div>

        <!-- å…¬å…±ç»“æœåŒº -->
        <div class="result-container">
            <h3>è¯†åˆ«ç»“æœ:</h3>
            <div id="resultText" class="result-text">ç­‰å¾…è¯†åˆ«...</div>
        </div>

        <!-- å…¬å…±æ—¥å¿—åŒº -->
        <div class="form-group">
            <label>å®æ—¶æ—¥å¿—:</label>
            <div id="log" class="log"></div>
        </div>
    </div>

    <script>
        // ==================== åè®®é…ç½®å¯¹è±¡ ====================
        const protocols = {
            aliyun: {
                name: 'aliyun',
                title: 'ğŸ¤ é˜¿é‡Œäº‘å®æ—¶è¯­éŸ³è¯†åˆ«æµ‹è¯•',
                desc: 'WebSocketæµå¼è¯­éŸ³è¯†åˆ«åè®® - StartTranscription â†’ å‘é€éŸ³é¢‘æµ â†’ StopTranscription',
                info: '<strong>åè®®è¯´æ˜ï¼š</strong>æœ¬é¡µé¢æ”¯æŒé€šè¿‡éº¦å…‹é£å®æ—¶å½•éŸ³å¹¶è¿›è¡Œè¯­éŸ³è¯†åˆ«ã€‚ç‚¹å‡»"å¼€å§‹è¯†åˆ«"åï¼Œè¯´è¯å†…å®¹å°†å®æ—¶è½¬æ¢ä¸ºæ–‡å­—ã€‚',
                defaultUrl: 'ws://localhost:8000/ws/v1/asr/funasr',
                // é˜¿é‡Œäº‘ç‰¹æœ‰çŠ¶æ€
                taskId: null,
                sentenceCount: 0,
                sentences: {},
                recordedBlob: null,
                // æ„å»ºå¼€å§‹æ¶ˆæ¯
                buildStartMsg: function(taskId) {
                    const format = document.getElementById('aliyun-format').value;
                    const sampleRate = parseInt(document.getElementById('aliyun-sampleRate').value);
                    const enableIntermediate = document.getElementById('aliyun-enableIntermediate').value === 'true';
                    const enablePunctuation = document.getElementById('aliyun-enablePunctuation').value === 'true';

                    return {
                        header: {
                            message_id: generateMessageId(),
                            task_id: taskId,
                            namespace: 'SpeechTranscriber',
                            name: 'StartTranscription'
                        },
                        payload: {
                            format: format,
                            sample_rate: sampleRate,
                            enable_intermediate_result: enableIntermediate,
                            enable_punctuation_prediction: enablePunctuation,
                            enable_inverse_text_normalization: true
                        }
                    };
                },
                // æ„å»ºåœæ­¢æ¶ˆæ¯
                buildStopMsg: function(taskId) {
                    return {
                        header: {
                            message_id: generateMessageId(),
                            task_id: taskId,
                            namespace: 'SpeechTranscriber',
                            name: 'StopTranscription'
                        }
                    };
                },
                // å¤„ç†æ¶ˆæ¯
                handleMessage: async function(response) {
                    const header = response.header || {};
                    const payload = response.payload || {};
                    const name = header.name || '';
                    const status = header.status || 0;

                    log(`â† æ”¶åˆ°æ¶ˆæ¯: ${name} (status: ${status})`, status === 20000000 ? 'success' : 'warning');
                    if (Object.keys(payload).length > 0) {
                        log(`   payload: ${JSON.stringify(payload)}`, 'info');
                    }

                    switch (name) {
                        case 'TranscriptionStarted':
                            if (status === 20000000) {
                                updateStatus('è¯†åˆ«å·²å¼€å§‹ï¼Œæ­£åœ¨ç›‘å¬...', 'success');
                                log('âœ… è¯†åˆ«å·²å¼€å§‹', 'success');
                                await startMicrophone();
                            } else {
                                throw new Error('TranscriptionStartedå¤±è´¥: ' + header.status_message);
                            }
                            break;

                        case 'SentenceBegin':
                            const beginIndex = payload.index ?? '';
                            const beginTime = payload.time ?? 0;
                            log(`ğŸŸ¢ å¥å­å¼€å§‹ #${beginIndex} (time: ${beginTime}ms)`, 'success');
                            log(`   [VAD] æ£€æµ‹åˆ°è¯­éŸ³æ´»åŠ¨å¼€å§‹ï¼Œå¼€å§‹è¯†åˆ«æ–°å¥å­`, 'info');
                            break;

                        case 'TranscriptionResultChanged':
                            const intermediateText = payload.result || '';
                            const interimIndex = payload.index ?? 1;
                            const interimTime = payload.time ?? 0;
                            log(`â™ª ä¸­é—´ç»“æœ #${interimIndex} (time: ${interimTime}ms): "${intermediateText}"`, 'info');
                            this.updateResult(interimIndex, intermediateText, false);
                            break;

                        case 'SentenceEnd':
                            const finalText = payload.result || '';
                            const endIndex = payload.index ?? 1;
                            const endTime = payload.time ?? 0;
                            const beginTimeFromPayload = payload.begin_time ?? 0;
                            const sentenceDuration = endTime - beginTimeFromPayload;

                            this.sentenceCount++;
                            updateStats();

                            log(`ğŸ”´ å¥å­ç»“æŸ #${endIndex} (time: ${endTime}ms, duration: ${sentenceDuration}ms): "${finalText}"`, 'success');
                            log(`   [VAD] å¥å­å®Œæˆ: å¼€å§‹=${beginTimeFromPayload}ms, ç»“æŸ=${endTime}ms, æ—¶é•¿=${sentenceDuration}ms`, 'info');

                            this.updateResult(endIndex, finalText, true);
                            break;

                        case 'TranscriptionCompleted':
                            updateStatus('è¯†åˆ«å®Œæˆï¼', 'success');
                            log('ğŸ‰ è¯†åˆ«å®Œæˆ', 'success');
                            updateStats();
                            saveRecordedAudio();
                            if (websocket) {
                                websocket.close();
                            }
                            break;

                        case 'TaskFailed':
                            const reason = header.status_text || 'æœªçŸ¥é”™è¯¯';
                            updateStatus('ä»»åŠ¡å¤±è´¥: ' + reason, 'error');
                            log('âŒ ä»»åŠ¡å¤±è´¥: ' + reason, 'error');
                            if (websocket) {
                                websocket.close();
                            }
                            break;

                        default:
                            log(`âš ï¸ æ”¶åˆ°æœªçŸ¥æ¶ˆæ¯: ${name}`, 'warning');
                            log(`   å®Œæ•´æ¶ˆæ¯: ${JSON.stringify(response)}`, 'warning');
                            break;
                    }
                },
                // æ›´æ–°ç»“æœæ˜¾ç¤ºï¼ˆå¥å­çº§ï¼‰
                updateResult: function(index, text, isFinal = false) {
                    if (!this.sentences[index]) {
                        this.sentences[index] = { text: "", isFinal: false };
                    }
                    this.sentences[index].text = text;
                    this.sentences[index].isFinal = isFinal;

                    const resultEl = document.getElementById('resultText');
                    let displayHtml = "";
                    const indices = Object.keys(this.sentences).map(Number).sort((a, b) => a - b);

                    for (let i = 0; i < indices.length; i++) {
                        const idx = indices[i];
                        const sentence = this.sentences[idx];

                        if (i > 0) {
                            displayHtml += " ";
                        }

                        if (sentence.isFinal) {
                            displayHtml += sentence.text;
                        } else {
                            displayHtml += `<span style="color: #999; font-style: italic;">${sentence.text}</span>`;
                        }
                    }

                    resultEl.innerHTML = displayHtml || "ç­‰å¾…è¯†åˆ«...";
                    resultEl.scrollTop = resultEl.scrollHeight;
                },
                // é‡ç½®çŠ¶æ€
                reset: function() {
                    this.taskId = generateUUID();
                    this.sentenceCount = 0;
                    this.sentences = {};
                    this.recordedBlob = null;
                },
                // è·å–é‡‡æ ·ç‡
                getSampleRate: function() {
                    return parseInt(document.getElementById('aliyun-sampleRate').value);
                },
                // è·å–Chunkæ­¥é•¿ï¼ˆå›ºå®š600msï¼‰
                getChunkStride: function() {
                    return 9600; // 600ms at 16kHz
                },
                // æ˜¾ç¤ºç»Ÿè®¡
                showStats: function() {
                    document.getElementById('sentenceCountStat').style.display = 'block';
                    document.getElementById('detectedLanguageStat').style.display = 'none';
                }
            },

            qwen3: {
                name: 'qwen3',
                title: 'ğŸ¤ Qwen3-ASRæµå¼è¯­éŸ³è¯†åˆ«æµ‹è¯•',
                desc: 'WebSocketæµå¼è¯­éŸ³è¯†åˆ« - vLLMåç«¯ç´¯ç§¯é‡æ¨ç†æœºåˆ¶ | æ”¯æŒ52+ç§è¯­è¨€è‡ªåŠ¨æ£€æµ‹',
                info: '<strong>åè®®è¯´æ˜ï¼š</strong>æœ¬é¡µé¢æ”¯æŒé€šè¿‡éº¦å…‹é£å®æ—¶å½•éŸ³å¹¶è¿›è¡Œè¯­éŸ³è¯†åˆ«ã€‚ç‚¹å‡»"å¼€å§‹è¯†åˆ«"åï¼Œè¯´è¯å†…å®¹å°†å®æ—¶è½¬æ¢ä¸ºæ–‡å­—ã€‚Qwen3-ASRä½¿ç”¨ç´¯ç§¯é‡æ¨ç†æœºåˆ¶ï¼Œæ¯æ¬¡å°†å·²æ¥æ”¶çš„å…¨éƒ¨éŸ³é¢‘é‡æ–°é€å…¥vLLMæ¨¡å‹ã€‚',
                defaultUrl: 'ws://localhost:8000/ws/v1/asr/qwen',
                // Qwen3ç‰¹æœ‰çŠ¶æ€
                currentText: "",
                detectedLanguage: "",
                // æ„å»ºå¼€å§‹æ¶ˆæ¯
                buildStartMsg: function() {
                    const chunkSizeSec = parseFloat(document.getElementById('qwen3-chunkSizeSec').value);
                    const language = document.getElementById('qwen3-language').value || null;
                    const context = document.getElementById('qwen3-context').value;

                    return {
                        type: 'start',
                        payload: {
                            format: 'pcm',
                            sample_rate: 16000,
                            chunk_size_sec: chunkSizeSec,
                            language: language,
                            context: context,
                            unfixed_chunk_num: 2,
                            unfixed_token_num: 5
                        }
                    };
                },
                // æ„å»ºåœæ­¢æ¶ˆæ¯
                buildStopMsg: function() {
                    return { type: 'stop' };
                },
                // å¤„ç†æ¶ˆæ¯
                handleMessage: async function(response) {
                    const type = response.type || '';

                    log('æ”¶åˆ°æ¶ˆæ¯: ' + type, type === 'error' ? 'error' : 'success');

                    switch (type) {
                        case 'started':
                            updateStatus('è¯†åˆ«å·²å¯åŠ¨ï¼Œæ­£åœ¨å¯åŠ¨éº¦å…‹é£...', 'success');
                            log('è¯†åˆ«å·²å¯åŠ¨ï¼Œå‚æ•°: ' + JSON.stringify(response.params), 'success');
                            await startMicrophone();
                            break;

                        case 'result':
                            if (response.results && response.results.length > 0) {
                                const result = response.results[response.results.length - 1];
                                log(`ä¸­é—´ç»“æœ [chunk ${result.chunk_id}]: "${result.text}"`, 'info');
                                this.updateResult(result.text, result.language);
                            }
                            break;

                        case 'final':
                            const finalResult = response.result;
                            this.updateResult(finalResult.text, finalResult.language);
                            updateStatus('è¯†åˆ«å®Œæˆï¼', 'success');
                            log(`è¯†åˆ«å®Œæˆï¼æ€»å—æ•°: ${finalResult.total_chunks}, è¯­è¨€: ${finalResult.language}`, 'success');
                            updateStats();

                            if (websocket) {
                                websocket.close();
                            }
                            break;

                        case 'error':
                            updateStatus('é”™è¯¯: ' + response.message, 'error');
                            log('é”™è¯¯: ' + response.message, 'error');
                            if (websocket) {
                                websocket.close();
                            }
                            break;

                        default:
                            log('æ”¶åˆ°æœªçŸ¥æ¶ˆæ¯: ' + JSON.stringify(response), 'warning');
                            break;
                    }
                },
                // æ›´æ–°ç»“æœæ˜¾ç¤ºï¼ˆç®€å•æ–‡æœ¬æ›¿æ¢ï¼‰
                updateResult: function(text, language) {
                    const resultEl = document.getElementById('resultText');
                    if (text) {
                        resultEl.textContent = text;
                        this.currentText = text;
                    }
                    if (language) {
                        this.detectedLanguage = language;
                        updateStats();
                    }
                },
                // é‡ç½®çŠ¶æ€
                reset: function() {
                    this.currentText = "";
                    this.detectedLanguage = "";
                },
                // è·å–é‡‡æ ·ç‡
                getSampleRate: function() {
                    return 16000;
                },
                // è·å–Chunkæ­¥é•¿ï¼ˆåŠ¨æ€ï¼‰
                getChunkStride: function() {
                    const chunkSizeSec = parseFloat(document.getElementById('qwen3-chunkSizeSec').value);
                    return Math.floor(16000 * chunkSizeSec);
                },
                // æ˜¾ç¤ºç»Ÿè®¡
                showStats: function() {
                    document.getElementById('sentenceCountStat').style.display = 'none';
                    document.getElementById('detectedLanguageStat').style.display = 'block';
                }
            }
        };

        // ==================== å…¨å±€çŠ¶æ€ ====================
        let currentProtocol = 'aliyun';
        let websocket = null;
        let audioContext = null;
        let mediaStream = null;
        let processor = null;
        let audioChunksCount = 0;
        let audioSizeTotal = 0;
        let startTime = null;
        let isRecording = false;
        let sendBuffer = [];
        let recordedAudioChunks = [];

        // ==================== å…¬å…±å‡½æ•° ====================
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            }).replace(/-/g, '').substring(0, 32);
        }

        function generateMessageId() {
            return generateUUID();
        }

        function log(message, type = 'info') {
            const logElement = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${timestamp}] ${message}`;
            logElement.appendChild(entry);
            logElement.scrollTop = logElement.scrollHeight;
        }

        function updateStatus(message, type = 'info') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }

        function updateStats() {
            document.getElementById('audioChunks').textContent = audioChunksCount;
            document.getElementById('audioSize').textContent = (audioSizeTotal / 1024).toFixed(1) + ' KB';
            document.getElementById('connectionState').textContent = isRecording ? (currentProtocol === 'aliyun' ? 'å½•éŸ³ä¸­' : 'è¯†åˆ«ä¸­') : 'æœªè¿æ¥';

            if (currentProtocol === 'aliyun') {
                document.getElementById('sentenceCount').textContent = protocols.aliyun.sentenceCount;
            } else {
                document.getElementById('detectedLanguage').textContent = protocols.qwen3.detectedLanguage || '-';
            }

            if (startTime) {
                const duration = (Date.now() - startTime) / 1000;
                document.getElementById('duration').textContent = duration.toFixed(1) + 's';
            }
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
            audioChunksCount = 0;
            audioSizeTotal = 0;
            startTime = null;
            updateStats();
        }

        function clearResult() {
            document.getElementById('resultText').textContent = 'ç­‰å¾…è¯†åˆ«...';
            if (currentProtocol === 'aliyun') {
                protocols.aliyun.sentences = {};
            } else {
                protocols.qwen3.currentText = "";
                protocols.qwen3.detectedLanguage = "";
            }
            updateStats();
        }

        function float32To16BitPCM(float32Array) {
            const buffer = new ArrayBuffer(float32Array.length * 2);
            const view = new DataView(buffer);
            let offset = 0;
            for (let i = 0; i < float32Array.length; i++, offset += 2) {
                const s = Math.max(-1, Math.min(1, float32Array[i]));
                view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
            }
            return new Int16Array(buffer);
        }

        // ==================== åè®®åˆ‡æ¢ ====================
        function switchProtocol(protocol) {
            if (isRecording) {
                updateStatus('è¯·å…ˆåœæ­¢å½“å‰è¯†åˆ«ä»»åŠ¡', 'warning');
                return;
            }

            currentProtocol = protocol;
            const config = protocols[protocol];

            // æ›´æ–°æ ‡ç­¾æ ·å¼
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`tab-${protocol}`).classList.add('active');

            // æ›´æ–°æ ‡é¢˜å’Œæè¿°
            document.getElementById('pageTitle').textContent = config.title;
            document.getElementById('pageDesc').textContent = config.desc;
            document.getElementById('protocolInfo').innerHTML = config.info;

            // æ›´æ–°WebSocketåœ°å€
            document.getElementById('wsUrl').value = config.defaultUrl;

            // åˆ‡æ¢é…ç½®åŒºæ˜¾ç¤º
            document.querySelectorAll('.config-section').forEach(section => section.classList.remove('active'));
            document.getElementById(`${protocol}-config`).classList.add('active');

            // åˆ‡æ¢ç»Ÿè®¡ä¿¡æ¯æ˜¾ç¤º
            config.showStats();

            // éšè—éŸ³é¢‘å›æ”¾åŒº
            document.getElementById('audioPlaybackContainer').style.display = 'none';

            // æ¸…ç©ºç»“æœ
            clearResult();
            clearLog();

            log(`å·²åˆ‡æ¢åˆ° ${protocol === 'aliyun' ? 'é˜¿é‡Œäº‘' : 'Qwen3-ASR'} åè®®`, 'success');
        }

        // ==================== éŸ³é¢‘é‡‡é›† ====================
        async function startMicrophone() {
            try {
                const protocol = protocols[currentProtocol];
                const sampleRate = protocol.getSampleRate();
                const chunkStride = protocol.getChunkStride();

                recordedAudioChunks = [];
                sendBuffer = [];
                document.getElementById('audioPlaybackContainer').style.display = 'none';

                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        sampleRate: sampleRate,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                });

                mediaStream = stream;

                audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: sampleRate });
                const source = audioContext.createMediaStreamSource(stream);

                const bufferSize = 4096;
                processor = audioContext.createScriptProcessor(bufferSize, 1, 1);

                log(`éŸ³é¢‘å¤„ç†é…ç½®: bufferSize=${bufferSize}, chunkStride=${chunkStride}æ ·æœ¬ (${(chunkStride/sampleRate*1000).toFixed(0)}ms)`, 'info');

                processor.onaudioprocess = (event) => {
                    if (websocket && websocket.readyState === WebSocket.OPEN) {
                        const audioData = event.inputBuffer.getChannelData(0);

                        let sum = 0;
                        let max = 0;
                        for (let i = 0; i < audioData.length; i++) {
                            const abs = Math.abs(audioData[i]);
                            sum += abs;
                            if (abs > max) max = abs;
                        }
                        const mean = sum / audioData.length;

                        const pcmData = float32To16BitPCM(audioData);

                        recordedAudioChunks.push(new Int16Array(pcmData));

                        sendBuffer.push(new Int16Array(pcmData));
                        const currentBufferLength = sendBuffer.reduce((sum, chunk) => sum + chunk.length, 0);

                        if (currentBufferLength >= chunkStride) {
                            const sendData = new Int16Array(chunkStride);
                            let offset = 0;
                            let remaining = chunkStride;

                            while (remaining > 0 && sendBuffer.length > 0) {
                                const chunk = sendBuffer[0];
                                const copyLength = Math.min(remaining, chunk.length);
                                sendData.set(chunk.subarray(0, copyLength), offset);
                                offset += copyLength;
                                remaining -= copyLength;

                                if (copyLength >= chunk.length) {
                                    sendBuffer.shift();
                                } else {
                                    sendBuffer[0] = chunk.subarray(copyLength);
                                }
                            }

                            websocket.send(sendData.buffer);
                            audioChunksCount++;
                            audioSizeTotal += sendData.buffer.byteLength;

                            const durationMs = (chunkStride / sampleRate * 1000).toFixed(0);
                            if (mean > 0.001) {
                                const prefix = currentProtocol === 'aliyun' ? 'ğŸ“¤ ' : '';
                                log(`${prefix}å‘é€éŸ³é¢‘å— #${audioChunksCount}: size=${sendData.buffer.byteLength}B, samples=${chunkStride}, duration=${durationMs}ms, max=${max.toFixed(4)}, mean=${mean.toFixed(6)}`, 'info');
                            }
                        }

                        updateStats();
                    }
                };

                source.connect(processor);
                processor.connect(audioContext.destination);

                isRecording = true;
                document.getElementById('stopBtn').disabled = false;
                updateStatus('æ­£åœ¨è¯†åˆ«ä¸­...è¯·è¯´è¯', 'success');
                log(currentProtocol === 'aliyun' ? 'âœ… éº¦å…‹é£å·²å¯åŠ¨ï¼Œå¼€å§‹å½•éŸ³' : 'éº¦å…‹é£å·²å¯åŠ¨ï¼Œå¼€å§‹å½•éŸ³', 'success');

            } catch (e) {
                log('éº¦å…‹é£å¯åŠ¨å¤±è´¥: ' + e.message, 'error');
                updateStatus('éº¦å…‹é£å¯åŠ¨å¤±è´¥: ' + e.message, 'error');
            }
        }

        // ==================== WebSocket ç”Ÿå‘½å‘¨æœŸ ====================
        async function startRecognition() {
            const wsUrl = document.getElementById('wsUrl').value;
            const protocol = protocols[currentProtocol];

            if (isRecording) {
                updateStatus('è¯†åˆ«å·²åœ¨è¿›è¡Œä¸­', 'warning');
                return;
            }

            try {
                // é‡ç½®çŠ¶æ€
                audioChunksCount = 0;
                audioSizeTotal = 0;
                startTime = Date.now();
                sendBuffer = [];
                recordedAudioChunks = [];
                protocol.reset();

                updateStatus('æ­£åœ¨è¿æ¥WebSocket...', 'info');
                log('å¼€å§‹è¿æ¥WebSocket: ' + wsUrl, 'info');

                websocket = new WebSocket(wsUrl);
                websocket.binaryType = 'arraybuffer';

                websocket.onopen = async () => {
                    updateStats();
                    updateStatus('WebSocketè¿æ¥æˆåŠŸï¼Œæ­£åœ¨å‘é€å¼€å§‹æ¶ˆæ¯...', 'success');
                    log(currentProtocol === 'aliyun' ? 'âœ… WebSocketè¿æ¥æˆåŠŸ' : 'WebSocketè¿æ¥æˆåŠŸ', 'success');

                    if (currentProtocol === 'aliyun') {
                        const msg = protocol.buildStartMsg(protocol.taskId);
                        websocket.send(JSON.stringify(msg));
                        log('â†’ å‘é€StartTranscription', 'info');
                        // é˜¿é‡Œäº‘åœ¨æ”¶åˆ°TranscriptionStartedåå¯åŠ¨éº¦å…‹é£
                    } else {
                        const msg = protocol.buildStartMsg();
                        websocket.send(JSON.stringify(msg));
                        log('å‘é€Startæ¶ˆæ¯: ' + JSON.stringify(msg), 'info');
                    }
                };

                websocket.onmessage = async (event) => {
                    try {
                        const response = JSON.parse(event.data);
                        await protocol.handleMessage(response);
                    } catch (e) {
                        log('è§£æJSONå“åº”å¤±è´¥: ' + e.message, 'error');
                    }
                };

                websocket.onerror = (error) => {
                    log('WebSocketé”™è¯¯' + (currentProtocol === 'aliyun' ? ': ' + error : ''), 'error');
                    updateStatus('WebSocketè¿æ¥é”™è¯¯', 'error');
                };

                websocket.onclose = () => {
                    isRecording = false;
                    updateStats();
                    updateStatus('WebSocketè¿æ¥å·²å…³é—­', 'info');
                    log('WebSocketè¿æ¥å·²å…³é—­', 'info');
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('stopBtn').disabled = true;

                    if (mediaStream) {
                        mediaStream.getTracks().forEach(track => track.stop());
                    }
                };

                document.getElementById('startBtn').disabled = true;

            } catch (e) {
                updateStatus('å¯åŠ¨å¤±è´¥: ' + e.message, 'error');
                log('å¯åŠ¨å¤±è´¥: ' + e.message, 'error');
            }
        }

        async function stopRecognition() {
            const protocol = protocols[currentProtocol];

            if (websocket) {
                // å‘é€å‰©ä½™éŸ³é¢‘
                if (sendBuffer.length > 0) {
                    const currentBufferLength = sendBuffer.reduce((sum, chunk) => sum + chunk.length, 0);
                    const mergedData = new Int16Array(currentBufferLength);
                    let offset = 0;
                    for (const chunk of sendBuffer) {
                        mergedData.set(chunk, offset);
                        offset += chunk.length;
                    }
                    websocket.send(mergedData.buffer);
                    const sampleRate = protocol.getSampleRate();
                    const durationMs = (currentBufferLength / sampleRate * 1000).toFixed(0);
                    const prefix = currentProtocol === 'aliyun' ? 'ğŸ“¤ ' : '';
                    log(`${prefix}å‘é€å‰©ä½™éŸ³é¢‘: size=${mergedData.buffer.byteLength}B, samples=${currentBufferLength}, duration=${durationMs}ms`, 'info');
                    sendBuffer = [];
                }

                // åœæ­¢éŸ³é¢‘å¤„ç†
                if (processor) {
                    processor.disconnect();
                    processor = null;
                }
                if (mediaStream) {
                    mediaStream.getTracks().forEach(track => track.stop());
                    mediaStream = null;
                }
                if (audioContext) {
                    audioContext.close();
                    audioContext = null;
                }

                // å‘é€åœæ­¢æ¶ˆæ¯
                if (currentProtocol === 'aliyun') {
                    const msg = protocol.buildStopMsg(protocol.taskId);
                    websocket.send(JSON.stringify(msg));
                    log('â†’ å‘é€StopTranscription', 'info');
                } else {
                    const msg = protocol.buildStopMsg();
                    websocket.send(JSON.stringify(msg));
                    log('å‘é€Stopæ¶ˆæ¯', 'info');
                }

                updateStatus('æ­£åœ¨åœæ­¢è¯†åˆ«...', 'info');
                document.getElementById('stopBtn').disabled = true;
            } else {
                updateStatus('æ²¡æœ‰æ­£åœ¨è¿›è¡Œçš„è¯†åˆ«ä»»åŠ¡', 'warning');
            }
        }

        // ==================== é˜¿é‡Œäº‘ç‰¹æœ‰åŠŸèƒ½ï¼šå½•éŸ³ä¿å­˜å’Œä¸‹è½½ ====================
        function saveRecordedAudio() {
            if (currentProtocol !== 'aliyun') return;

            if (recordedAudioChunks.length === 0) {
                log('æ²¡æœ‰å½•éŸ³æ•°æ®', 'warning');
                return;
            }

            try {
                const totalLength = recordedAudioChunks.reduce((acc, chunk) => acc + chunk.length, 0);
                const mergedData = new Int16Array(totalLength);
                let offset = 0;
                for (const chunk of recordedAudioChunks) {
                    mergedData.set(chunk, offset);
                    offset += chunk.length;
                }

                const sampleRate = protocols.aliyun.getSampleRate();
                const wavBlob = createWavBlob(mergedData, sampleRate);
                protocols.aliyun.recordedBlob = wavBlob;

                const audioPlayback = document.getElementById('audioPlayback');
                const url = URL.createObjectURL(wavBlob);
                audioPlayback.src = url;
                document.getElementById('audioPlaybackContainer').style.display = 'block';

                log(`âœ… å½•éŸ³å·²ä¿å­˜ (${(wavBlob.size / 1024).toFixed(1)} KB, ${(totalLength / sampleRate).toFixed(1)}s)`, 'success');
            } catch (e) {
                log('ä¿å­˜å½•éŸ³å¤±è´¥: ' + e.message, 'error');
            }
        }

        function createWavBlob(pcmData, sampleRate) {
            const numChannels = 1;
            const bitsPerSample = 16;
            const bytesPerSample = bitsPerSample / 8;
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const dataSize = pcmData.length * bytesPerSample;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);

            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');

            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitsPerSample, true);

            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);

            const offset = 44;
            for (let i = 0; i < pcmData.length; i++) {
                view.setInt16(offset + i * 2, pcmData[i], true);
            }

            return new Blob([buffer], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        function downloadAudio() {
            if (currentProtocol !== 'aliyun') return;

            const blob = protocols.aliyun.recordedBlob;
            if (!blob) {
                log('æ²¡æœ‰å¯ä¸‹è½½çš„å½•éŸ³', 'warning');
                return;
            }

            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `recording_${new Date().getTime()}.wav`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            log('âœ… å½•éŸ³å·²ä¸‹è½½', 'success');
        }

        // ==================== åˆå§‹åŒ– ====================
        window.onload = function() {
            updateStats();
            protocols.aliyun.showStats();
            log('ASRå®æ—¶è¯­éŸ³è¯†åˆ«æµ‹è¯•é¡µé¢å·²åŠ è½½ (å½“å‰åè®®: é˜¿é‡Œäº‘)', 'success');
        };

        window.onbeforeunload = function() {
            if (websocket) {
                websocket.close();
            }
            if (audioContext) {
                audioContext.close();
            }
        };
    </script>
</body>
</html>
