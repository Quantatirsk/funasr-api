<!DOCTYPE html>
<html>
<head>
    <title>Qwen3-ASRæµå¼è¯­éŸ³è¯†åˆ«æµ‹è¯•</title>
    <meta charset="utf-8">
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .header { text-align: center; margin-bottom: 30px; }
        .form-row { display: flex; gap: 20px; margin-bottom: 15px; align-items: end; }
        .form-group { flex: 1; }
        label { display: block; margin-bottom: 5px; font-weight: bold; color: #333; }
        input, select { width: 100%; padding: 8px; box-sizing: border-box; border: 1px solid #ddd; border-radius: 4px; }
        button { background: #007bff; color: white; padding: 10px 20px; border: none; cursor: pointer; border-radius: 4px; font-size: 14px; margin: 5px; }
        button:hover { background: #0056b3; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        button.success { background: #28a745; }
        button.danger { background: #dc3545; }
        .controls { text-align: center; margin: 20px 0; }
        .status { padding: 10px; margin: 10px 0; border-radius: 4px; }
        .status.info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        .status.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status.error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .log { background: #f8f9fa; border: 1px solid #ddd; padding: 15px; height: 400px; overflow-y: auto; font-family: 'Courier New', monospace; font-size: 12px; border-radius: 4px; }
        .log-entry { margin: 2px 0; padding: 2px 5px; border-radius: 3px; }
        .log-entry.info { color: #0c5460; }
        .log-entry.success { color: #155724; }
        .log-entry.error { color: #721c24; background: rgba(248, 215, 218, 0.3); }
        .log-entry.warning { color: #856404; background: rgba(255, 243, 205, 0.3); }
        .result-container { margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 4px; }
        .result-text { font-size: 16px; line-height: 1.8; padding: 15px; background: white; border: 1px solid #ddd; border-radius: 4px; min-height: 150px; max-height: 300px; overflow-y: auto; white-space: pre-wrap; word-wrap: break-word; }
        .stats { display: flex; gap: 20px; margin: 15px 0; }
        .stat { background: #e9ecef; padding: 10px; border-radius: 4px; text-align: center; flex: 1; }
        .stat-value { font-size: 18px; font-weight: bold; color: #007bff; }
        .stat-label { font-size: 12px; color: #666; }
        .protocol-info { background: #e7f3ff; padding: 15px; margin: 15px 0; border-radius: 4px; border-left: 4px solid #007bff; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¤ Qwen3-ASRæµå¼è¯­éŸ³è¯†åˆ«æµ‹è¯•</h1>
            <p>WebSocketæµå¼è¯­éŸ³è¯†åˆ« - vLLMåç«¯ç´¯ç§¯é‡æ¨ç†æœºåˆ¶ | æ”¯æŒ52+ç§è¯­è¨€è‡ªåŠ¨æ£€æµ‹</p>
        </div>

        <div class="protocol-info">
            <strong>åè®®è¯´æ˜ï¼š</strong>æœ¬é¡µé¢æ”¯æŒé€šè¿‡éº¦å…‹é£å®æ—¶å½•éŸ³å¹¶è¿›è¡Œè¯­éŸ³è¯†åˆ«ã€‚ç‚¹å‡»"å¼€å§‹è¯†åˆ«"åï¼Œè¯´è¯å†…å®¹å°†å®æ—¶è½¬æ¢ä¸ºæ–‡å­—ã€‚
            Qwen3-ASRä½¿ç”¨ç´¯ç§¯é‡æ¨ç†æœºåˆ¶ï¼Œæ¯æ¬¡å°†å·²æ¥æ”¶çš„å…¨éƒ¨éŸ³é¢‘é‡æ–°é€å…¥vLLMæ¨¡å‹ã€‚
        </div>

        <div class="form-row">
            <div class="form-group">
                <label>WebSocketæœåŠ¡åœ°å€:</label>
                <input type="text" id="wsUrl" value="ws://localhost:8000/ws/v1/qwen3/asr" />
            </div>
        </div>

        <div class="form-row">
            <div class="form-group">
                <label>éŸ³é¢‘æ ¼å¼:</label>
                <select id="format">
                    <option value="pcm" selected>PCM (16ä½)</option>
                </select>
            </div>
            <div class="form-group">
                <label>é‡‡æ ·ç‡:</label>
                <select id="sampleRate">
                    <option value="16000" selected>16000</option>
                </select>
            </div>
            <div class="form-group">
                <label>Chunkå¤§å°(ç§’):</label>
                <select id="chunkSizeSec">
                    <option value="0.5">0.5</option>
                    <option value="1.0">1.0</option>
                    <option value="2.0" selected>2.0</option>
                    <option value="4.0">4.0</option>
                </select>
            </div>
            <div class="form-group">
                <label>å¼ºåˆ¶è¯­è¨€:</label>
                <select id="language">
                    <option value="" selected>è‡ªåŠ¨æ£€æµ‹</option>
                    <option value="Chinese">Chinese</option>
                    <option value="English">English</option>
                    <option value="Japanese">Japanese</option>
                    <option value="Korean">Korean</option>
                    <option value="French">French</option>
                    <option value="German">German</option>
                    <option value="Spanish">Spanish</option>
                </select>
            </div>
        </div>

        <div class="form-row">
            <div class="form-group">
                <label>çƒ­è¯/ä¸Šä¸‹æ–‡:</label>
                <input type="text" id="context" placeholder="å¯é€‰: è¾“å…¥çƒ­è¯æˆ–ä¸Šä¸‹æ–‡æç¤º" />
            </div>
        </div>

        <div class="controls">
            <button id="startBtn" onclick="startRecognition()" class="success">ğŸ™ï¸ å¼€å§‹è¯†åˆ«</button>
            <button id="stopBtn" onclick="stopRecognition()" disabled class="danger">ğŸ›‘ åœæ­¢è¯†åˆ«</button>
            <button onclick="clearLog()">ğŸ—‘ï¸ æ¸…ç©ºæ—¥å¿—</button>
            <button onclick="clearResult()">ğŸ—‘ï¸ æ¸…ç©ºç»“æœ</button>
        </div>

        <div id="status" class="status info">å‡†å¤‡å°±ç»ªï¼Œç‚¹å‡»"å¼€å§‹è¯†åˆ«"æŒ‰é’®å¼€å§‹</div>

        <div class="stats">
            <div class="stat">
                <div class="stat-value" id="audioChunks">0</div>
                <div class="stat-label">éŸ³é¢‘å—æ•°</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="audioSize">0 KB</div>
                <div class="stat-label">éŸ³é¢‘å¤§å°</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="duration">0.0s</div>
                <div class="stat-label">è¯†åˆ«æ—¶é•¿</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="connectionState">æœªè¿æ¥</div>
                <div class="stat-label">è¿æ¥çŠ¶æ€</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="detectedLanguage">-</div>
                <div class="stat-label">æ£€æµ‹è¯­è¨€</div>
            </div>
        </div>

        <div class="result-container">
            <h3>è¯†åˆ«ç»“æœ:</h3>
            <div id="resultText" class="result-text">ç­‰å¾…è¯†åˆ«...</div>
        </div>

        <div class="form-group">
            <label>å®æ—¶æ—¥å¿—:</label>
            <div id="log" class="log"></div>
        </div>
    </div>

    <script>
        // Qwen3-ASR æµ‹è¯•é¡µé¢ JavaScript
        let websocket = null;
        let audioContext = null;
        let mediaStream = null;
        let processor = null;
        let audioChunksCount = 0;
        let audioSizeTotal = 0;
        let startTime = null;
        let isRecording = false;
        let currentText = "";
        let detectedLanguage = "";
        let sendBuffer = [];
        let recordedAudioChunks = [];

        function log(message, type = 'info') {
            const logElement = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${timestamp}] ${message}`;
            logElement.appendChild(entry);
            logElement.scrollTop = logElement.scrollHeight;
        }

        function updateStatus(message, type = 'info') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }

        function updateStats() {
            document.getElementById('audioChunks').textContent = audioChunksCount;
            document.getElementById('audioSize').textContent = (audioSizeTotal / 1024).toFixed(1) + ' KB';
            document.getElementById('connectionState').textContent = isRecording ? 'è¯†åˆ«ä¸­' : 'æœªè¿æ¥';
            document.getElementById('detectedLanguage').textContent = detectedLanguage || '-';

            if (startTime) {
                const duration = (Date.now() - startTime) / 1000;
                document.getElementById('duration').textContent = duration.toFixed(1) + 's';
            }
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
            audioChunksCount = 0;
            audioSizeTotal = 0;
            startTime = null;
            updateStats();
        }

        function clearResult() {
            document.getElementById('resultText').textContent = 'ç­‰å¾…è¯†åˆ«...';
            currentText = "";
            detectedLanguage = "";
            updateStats();
        }

        function updateResultDisplay(text, language) {
            const resultEl = document.getElementById('resultText');
            if (text) {
                resultEl.textContent = text;
                currentText = text;
            }
            if (language) {
                detectedLanguage = language;
                updateStats();
            }
        }

        async function startRecognition() {
            const wsUrl = document.getElementById('wsUrl').value;

            if (isRecording) {
                updateStatus('è¯†åˆ«å·²åœ¨è¿›è¡Œä¸­', 'warning');
                return;
            }

            try {
                audioChunksCount = 0;
                audioSizeTotal = 0;
                startTime = Date.now();
                currentText = "";
                detectedLanguage = "";
                sendBuffer = [];
                recordedAudioChunks = [];

                updateStatus('æ­£åœ¨è¿æ¥WebSocket...', 'info');
                log('å¼€å§‹è¿æ¥WebSocket: ' + wsUrl, 'info');

                websocket = new WebSocket(wsUrl);
                websocket.binaryType = 'arraybuffer';

                websocket.onopen = async () => {
                    updateStats();
                    updateStatus('WebSocketè¿æ¥æˆåŠŸï¼Œæ­£åœ¨å‘é€å¼€å§‹æ¶ˆæ¯...', 'success');
                    log('WebSocketè¿æ¥æˆåŠŸ', 'success');
                    await sendStartMessage();
                };

                websocket.onmessage = async (event) => {
                    try {
                        const response = JSON.parse(event.data);
                        await handleMessage(response);
                    } catch (e) {
                        log('è§£æJSONå“åº”å¤±è´¥: ' + e.message, 'error');
                    }
                };

                websocket.onerror = (error) => {
                    log('WebSocketé”™è¯¯', 'error');
                    updateStatus('WebSocketè¿æ¥é”™è¯¯', 'error');
                };

                websocket.onclose = () => {
                    isRecording = false;
                    updateStats();
                    updateStatus('WebSocketè¿æ¥å·²å…³é—­', 'info');
                    log('WebSocketè¿æ¥å·²å…³é—­', 'info');
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('stopBtn').disabled = true;

                    if (mediaStream) {
                        mediaStream.getTracks().forEach(track => track.stop());
                    }
                };

                document.getElementById('startBtn').disabled = true;

            } catch (e) {
                updateStatus('å¯åŠ¨å¤±è´¥: ' + e.message, 'error');
                log('å¯åŠ¨å¤±è´¥: ' + e.message, 'error');
            }
        }

        async function sendStartMessage() {
            const chunkSizeSec = parseFloat(document.getElementById('chunkSizeSec').value);
            const language = document.getElementById('language').value || null;
            const context = document.getElementById('context').value;

            const message = {
                type: 'start',
                payload: {
                    format: 'pcm',
                    sample_rate: 16000,
                    chunk_size_sec: chunkSizeSec,
                    language: language,
                    context: context,
                    unfixed_chunk_num: 2,
                    unfixed_token_num: 5
                }
            };

            websocket.send(JSON.stringify(message));
            log('å‘é€Startæ¶ˆæ¯: ' + JSON.stringify(message), 'info');
        }

        async function handleMessage(response) {
            const type = response.type || '';

            log('æ”¶åˆ°æ¶ˆæ¯: ' + type, type === 'error' ? 'error' : 'success');

            switch (type) {
                case 'started':
                    updateStatus('è¯†åˆ«å·²å¯åŠ¨ï¼Œæ­£åœ¨å¯åŠ¨éº¦å…‹é£...', 'success');
                    log('è¯†åˆ«å·²å¯åŠ¨ï¼Œå‚æ•°: ' + JSON.stringify(response.params), 'success');
                    await startMicrophone();
                    break;

                case 'result':
                    if (response.results && response.results.length > 0) {
                        const result = response.results[response.results.length - 1];
                        log(`ä¸­é—´ç»“æœ [chunk ${result.chunk_id}]: "${result.text}"`, 'info');
                        updateResultDisplay(result.text, result.language);
                    }
                    break;

                case 'final':
                    const finalResult = response.result;
                    updateResultDisplay(finalResult.text, finalResult.language);
                    updateStatus('è¯†åˆ«å®Œæˆï¼', 'success');
                    log(`è¯†åˆ«å®Œæˆï¼æ€»å—æ•°: ${finalResult.total_chunks}, è¯­è¨€: ${finalResult.language}`, 'success');
                    updateStats();

                    if (websocket) {
                        websocket.close();
                    }
                    break;

                case 'error':
                    updateStatus('é”™è¯¯: ' + response.message, 'error');
                    log('é”™è¯¯: ' + response.message, 'error');
                    if (websocket) {
                        websocket.close();
                    }
                    break;

                default:
                    log('æ”¶åˆ°æœªçŸ¥æ¶ˆæ¯: ' + JSON.stringify(response), 'warning');
                    break;
            }
        }

        async function startMicrophone() {
            try {
                const sampleRate = 16000;
                const chunkSizeSec = parseFloat(document.getElementById('chunkSizeSec').value);
                const chunkStride = Math.floor(sampleRate * chunkSizeSec);

                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        sampleRate: sampleRate,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                });

                mediaStream = stream;

                audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: sampleRate });
                const source = audioContext.createMediaStreamSource(stream);

                const bufferSize = 4096;
                processor = audioContext.createScriptProcessor(bufferSize, 1, 1);

                log(`éŸ³é¢‘å¤„ç†é…ç½®: bufferSize=${bufferSize}, chunkStride=${chunkStride}æ ·æœ¬ (${chunkSizeSec}s)`, 'info');

                processor.onaudioprocess = (event) => {
                    if (websocket && websocket.readyState === WebSocket.OPEN) {
                        const audioData = event.inputBuffer.getChannelData(0);

                        let sum = 0;
                        let max = 0;
                        for (let i = 0; i < audioData.length; i++) {
                            const abs = Math.abs(audioData[i]);
                            sum += abs;
                            if (abs > max) max = abs;
                        }
                        const mean = sum / audioData.length;

                        const pcmData = float32To16BitPCM(audioData);

                        recordedAudioChunks.push(new Int16Array(pcmData));

                        sendBuffer.push(new Int16Array(pcmData));
                        const currentBufferLength = sendBuffer.reduce((sum, chunk) => sum + chunk.length, 0);

                        if (currentBufferLength >= chunkStride) {
                            const sendData = new Int16Array(chunkStride);
                            let offset = 0;
                            let remaining = chunkStride;

                            while (remaining > 0 && sendBuffer.length > 0) {
                                const chunk = sendBuffer[0];
                                const copyLength = Math.min(remaining, chunk.length);
                                sendData.set(chunk.subarray(0, copyLength), offset);
                                offset += copyLength;
                                remaining -= copyLength;

                                if (copyLength >= chunk.length) {
                                    sendBuffer.shift();
                                } else {
                                    sendBuffer[0] = chunk.subarray(copyLength);
                                }
                            }

                            websocket.send(sendData.buffer);
                            audioChunksCount++;
                            audioSizeTotal += sendData.buffer.byteLength;

                            const durationMs = (chunkStride / sampleRate * 1000).toFixed(0);
                            if (mean > 0.001) {
                                log(`å‘é€éŸ³é¢‘å— #${audioChunksCount}: size=${sendData.buffer.byteLength}B, samples=${chunkStride}, duration=${durationMs}ms, max=${max.toFixed(4)}, mean=${mean.toFixed(6)}`, 'info');
                            }
                        }

                        updateStats();
                    }
                };

                source.connect(processor);
                processor.connect(audioContext.destination);

                isRecording = true;
                document.getElementById('stopBtn').disabled = false;
                updateStatus('æ­£åœ¨è¯†åˆ«ä¸­...è¯·è¯´è¯', 'success');
                log('éº¦å…‹é£å·²å¯åŠ¨ï¼Œå¼€å§‹å½•éŸ³', 'success');

            } catch (e) {
                log('éº¦å…‹é£å¯åŠ¨å¤±è´¥: ' + e.message, 'error');
                updateStatus('éº¦å…‹é£å¯åŠ¨å¤±è´¥: ' + e.message, 'error');
            }
        }

        function float32To16BitPCM(float32Array) {
            const buffer = new ArrayBuffer(float32Array.length * 2);
            const view = new DataView(buffer);
            let offset = 0;
            for (let i = 0; i < float32Array.length; i++, offset += 2) {
                const s = Math.max(-1, Math.min(1, float32Array[i]));
                view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
            }
            return new Int16Array(buffer);
        }

        async function stopRecognition() {
            if (websocket) {
                if (sendBuffer.length > 0) {
                    const currentBufferLength = sendBuffer.reduce((sum, chunk) => sum + chunk.length, 0);
                    const mergedData = new Int16Array(currentBufferLength);
                    let offset = 0;
                    for (const chunk of sendBuffer) {
                        mergedData.set(chunk, offset);
                        offset += chunk.length;
                    }
                    websocket.send(mergedData.buffer);
                    const durationMs = (currentBufferLength / 16000 * 1000).toFixed(0);
                    log(`å‘é€å‰©ä½™éŸ³é¢‘: size=${mergedData.buffer.byteLength}B, samples=${currentBufferLength}, duration=${durationMs}ms`, 'info');
                    sendBuffer = [];
                }

                if (processor) {
                    processor.disconnect();
                    processor = null;
                }
                if (mediaStream) {
                    mediaStream.getTracks().forEach(track => track.stop());
                    mediaStream = null;
                }
                if (audioContext) {
                    audioContext.close();
                    audioContext = null;
                }

                const message = { type: 'stop' };
                websocket.send(JSON.stringify(message));
                log('å‘é€Stopæ¶ˆæ¯', 'info');
                updateStatus('æ­£åœ¨åœæ­¢è¯†åˆ«...', 'info');

                document.getElementById('stopBtn').disabled = true;
            } else {
                updateStatus('æ²¡æœ‰æ­£åœ¨è¿›è¡Œçš„è¯†åˆ«ä»»åŠ¡', 'warning');
            }
        }

        window.onload = function() {
            updateStats();
            log('Qwen3-ASRæµå¼è¯­éŸ³è¯†åˆ«æµ‹è¯•é¡µé¢å·²åŠ è½½', 'success');
        };

        window.onbeforeunload = function() {
            if (websocket) {
                websocket.close();
            }
            if (audioContext) {
                audioContext.close();
            }
        };
    </script>
</body>
</html>
